#!/usr/bin/env python3
'Output sorted summary of VIM plugin startup times in millisecs.'
# Mark Blakeney, Jan 2018
import os, sys, argparse, subprocess, tempfile
from pathlib import Path
from collections import defaultdict

HOME = Path.home()

opt = argparse.ArgumentParser(description=__doc__.strip())
opt.add_argument('-e', '--exe', default='vim',
        help='vim executable name, default="%(default)s"')
opt.add_argument('-n', '--num', type=int,
        help='limit output to given number of plugins')
args = opt.parse_args()

# Need file for vim to log to and an empty file for vim to open.
logfile = tempfile.NamedTemporaryFile('r')
tmpfile = tempfile.NamedTemporaryFile('r')
cmd = '{} -Xf --startuptime {} -cqa {}'.format(args.exe, logfile.name,
        tmpfile.name)
res = subprocess.run(cmd.split(), universal_newlines=True)

if res.returncode != 0:
    sys.exit('.. exited with vim error.')

# Create dict of paths and times
paths = defaultdict(float)
for line in logfile:
    if ': sourcing /' not in line:
        continue

    junk, junk, tstr, junk, fname = line.split()

    # Only concerned with personal plugins
    try:
        rpath = Path(fname).relative_to(HOME)
    except ValueError:
        continue

    paths[rpath] += float(tstr.rstrip(':'))

# Now remove any common path prefix
prefix = os.path.commonpath(paths)
paths = {Path(p).relative_to(prefix): v for p, v in paths.items()}

# Now assume plugin name is unique dir name in plugin dir and so tally
# times. We also skip autoloads.
times = defaultdict(float)
for path, val in paths.items():
    if path.parts[0] != 'autoload':
        times[path.parts[1]] += val

# Output sorted results
percent = 100. / sum(times.values())
for ind, plugin in enumerate(sorted(times, key=times.get, reverse=True), 1):
    if args.num and ind > args.num:
        break

    v = times[plugin]
    print('{:4}: {:9.3f} ({:4.1f}%) {}'.format(ind, v, v * percent, plugin))
